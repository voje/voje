ðŸ‘‹ Hi, my name's Kristjan.

ðŸ’« Professionally, I'm a DevOps Engineer at a telco company where I focus on Kubernetes and end-to-end deployment automation (deployment of whole platforms in air-gapped environments).   

Here's a high level overview of tools, languages, frameworks and platforms I'm comfortable with.   

Operating Systems and daily drivers:
* Ubuntu cloud -- most comfortable one
* Fedora, RHEL, RHCOS -- when working with Openshift, super secure, super annoying to configure Selinux
* Alpine -- base container image
* Arch -- old personal laptop, efficient use of hardware
* Windows + WSL2 -- current daily driver; good for programming (Linux shell) without losing Windows features (company compliance...)

Platforms:
* Openstack -- interaction via API, provision Tenants
* Kubernetes -- deployment from scratch; favorite distro is k3s, using Kubeadmin and Rancher for work projects
* Openshift 4 -- deployment from scratch (UPI), had to leran it for a work project, prefer vanilla Kubernetes
* AWS
* OCP

Tools:
* Terraform -- deploying VMs on cloud environments (Openstack, vSphere)
* Ansible -- provisioning remote (Linux) systems
* Helm -- deploying apps on K8s

Programming languages (proficiency/daily usage):
* Golang -- backend services, perfect for writing REST APIs (OpenAPI documentation)
* bash -- automation, scripting
* Python -- automation when bash gets too verbose; string manipulation with Jinja2; data manipulation with Pandas; general purpose get-stuff-done-quickly language

Other programming languages (pp - personal projects, uni - university, pro - professional development):
* Rust -- pp, staying in programming shape
* Kotlin -- pp, Android Studio app
* Elixir -- pp, web scraping
* Haskell -- pp. curiosity, learning functional languages
* C++ -- uni, pp, OpenCV, QT
* Java -- uni
* C -- uni
* JavaScript -- I like to use TypeScript wherever possible
  * Vue framework -- pro, dashboards for backend systems
  * React framework -- pp
  * Electron -- pp
